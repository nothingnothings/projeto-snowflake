






POR FIM, FALAREMOS SOBRE BEST PRACTICES 


SOBRE 

"RETENTION PERIOD' 

e

"TIME TRAVEL"....













É IMPORTANTE FALAR DISSO PQ

"TIME TRAVEL" É UMA FEATURE QUE 
GASTA STORAGE...





É UM COST FACTOR...









--> TALVEZ NEM TODA A DATA DE NOSSAS TABLES 

PRECISE 


DESSA CONTINOUS DATA PROTECTION CYCLE 
(usando 
o TIME TRAVEL E O FAILSAFE)...







QUER DIZER QUE ALGUMAS TABLES MENOS IMPORATNTES 



PODEMOS TER 


RETENTION PERIODS MENORES...









OUTRAS DATABASES E TABLES MAIS IMPORTANTES 

PODEM TER 
RETENTION PERIODS MAIORES...






--------------------------------







AS MELHORES PRACTICES SAO:










1) COM STAGING DATABASES E TABLES,

DEVEMOS DEIXAR 

O RETENTION PERIOD COMO "0"...




OU SEJA, PARA TRANSIENT TABLES,

DEVEMOS __dESABILITAR __ 


A FEATURE DE TIME TRAVEL,

POR MEIO 


DO SET DO RETENTION PERIOD COMO 
SENDO 0...




RESUMO: PARA STAGING DATABASES E TABLES,

E PARA DEV TABLES,

DEVEMOS:


1) CRIÁ-LAS COMO TRANSIENT TABLES.


2) CRIÁ-LAS COM A FEATURE DE TIME TRAVEL 
DESABILITADA (RETENTION_TIME_IN_DAYS=0)...











MAS PQ ISSO?




É PQ A DATA DESSA STAGING AREA É FACILMENTE 

OBTIDA 

LÁ DO SOURCE,


DO LADO DE FORA DO SNOWFLAKE,



E NAO FAZEMOS NENHUMA CHANGE 

NA STAGING AREA NESSA DATA... -> O ÚNICO 

OBJETIVO 


DA STAGING AREA É 

COLOCAR A DATA DENTRO DO NOSSO SNOWFLAKE 

APP,

CONSOLIDAR A DATA AQUI DENTRO,

PARA SÓ DEPOIS 

A MANIPULARMOS, EM OUTRAS TABLES....








certo... DEIXAMOS A TABLE COMO TRANSIENT 

E COM RETENTION TIME DE 0,



PARA FICARMOS SEM FAILSAFE E SEM TIME TRAVEL...















AGORA A SEGUNDA BEST PRACTICE:









2) SE TIVERMOS TABLES E DATABASES 

QUE ESTAO EM PRODUCTION,

É BOM TER 1 TIME TRAVEL PERIOD SETTADO....





--> ESSE PERIODO DE TIME TRAVEL 

PODE SER DE 4 A 7 DIAS... ( o mínimo é 1 dia)...





-> NAO PRECISA SER OBSCENAMENTE LARGO,


MAS 4 A 7 DIAS É OPTIMAL, 

PARA PRODUCTION TABLES...






---------------------------------










OUTRA BEST PRACTICE:










3) CASES EM QUE TEMOS TABLES 

ABSURDAMENTE LARGAS, 

E QUE 

SAO "LARGE HIGH-CHURN TABLES",


ou seja


TABLES QUE MUDAM COM MT FREQUENCIA...






EX: DIGAMOS QUE TEMOS 1 TABLE 

DE 20GB.... 


E ESSA TABLE DE 20GB MUDA CONSTANTEMENTE...




--> SE ELA MUDA COM MT FREQUENCIA,

E SE TIVERMOS 


1 TIME TRAVEL E FAIL SAFE SETTADOS 

COM ELA,

PODEMOS FICAR ASSIM:




ACTIVE: 20GB 


TIME TRAVEL: 400GB 


FAIL SAFE: 2TB...










E ISSO NAO É NADA BOM...








PARA EVITAR ISSO,



COM "LARGE HIGH-CHURN TABLES",




A MELHOR IDEIA POSSÍVEL 


É CRIAR 

ESSA 


TABLE COMO __ "TRANSIENT",



E DEFINIR O RETENTION PERIOD 


COMO 0 (para desabilitar 

o TIME TRAVEL, por inteiro)...










--> SE GASTARMOS 400GB EM 1 DIA DE TIME TRAVEL,

EM 7 DIAS

DE FAILSAFE GASTAREMOS/GASTAMOS 

2.8 TERABYTES (bem ruim)...










NESSES CASOS ESPECIAIS,

COM 

LARGE HIGH-CHURN TABLES,



VALE A PENA DESABILITAR O TIME TRAVEL (
    com RETENTION_TIME_IN_DAYS como 0
)

E 

CRIAR ESSA TABLE COMO TRANSIENT TABLE...






