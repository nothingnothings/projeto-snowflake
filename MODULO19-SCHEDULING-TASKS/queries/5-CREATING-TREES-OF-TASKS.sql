






AGORA DEVEMOS ESTUDAR A MANEIRA 
PELA QUAL PODEMOS 

IMPLEMENTAR ESSAS TREE OF TASKS...








COMECAMOS COM ESTE CÓDIGO:










USE TASK_DB;


SHOW TASKS;


SELECT * FROM CUSTOMERS;


-- Prepare a second table 
CREATE OR REPLACE TABLE CUSTOMERS_2 (
    CUSTOMER_ID INT,
    FIRST_NAME VARCHAR(40),
    CREATE_DATE DATE
);


-- Suspend parent task
ALTER TASK CUSTOMER_INSERT_TASK SUSPEND;

-- Create a child task 
CREATE OR REPLACE TASK CUSTOMER_INSERT_TASK_2
    WAREHOUSE = COMPUTE_WH
    AFTER CUSTOMER_INSERT_TASK
    AS









USAMOS ESSA DATABASE, 


PREPARAMOS ESSA SEGUNDA TABLE,

E AÍ 


SUSPENDEMOS A TASK QUE ESTAVA RODANDO ANTERIORMENTE....













NOSSA TASK, ANTERIORMENTE,



ESTAVA FAZENDO O INSERT DE NOVOS ROWS 


NA TABLE DE "CUSTOMERS",


1 NOVO INSERT A CADA MINUTO (
    ESSE ERA O SCHEDULE...
)










PREPARAMOS OS MESMOS 

COLUMN NAMES DA TABLE DE "CUSTOMERS",



MAS __ SEM AQUELES DEFAULT VALUES...






-> ISSO É PQ FAREMOS ALGO 1 POUCO DIFERENTE 

COM ESSA TABLE DE "cUSTOMERS_2"...









--> PARA CRIAR 1 CHILD TASK E 

A VINCULAR A 1 PARENT TASK (

    como essa task de "CUSTOMER_INSERT_TASK"
),

SEMPRE É MELHOR A SUSPENDER 

antes de fazer esse processo...







PARA CRIAR A CHILD TASK,


ESCREVEMOS ASSIM:







-- Create a child task 
CREATE OR REPLACE TASK CUSTOMER_INSERT_TASK_2
    WAREHOUSE = COMPUTE_WH
    AFTER CUSTOMER_INSERT_TASK
    AS 
    INSERT INTO CUSTOMERS_2 SELECT * FROM CUSTOMERS;














CERTO.... ISSO CRIARÁ ESSA TASK,


SIM...








MAS DEVEMOS SEMPRE NOS LEMBRAR:


TASKS CRIADAS NO SNOWFLAKE INICIALMENTE 

FICAM EM 1 STATE DE "SUSPENDED",

O QUE QUER DIZER QUE, PARA FUNCIONAREM,



É NECESSÁRIO 


ESCREVER 1 COMANDO COMO 





ALTER TASK CUSTOMER_INSERT_TASK_2 RESUME;















MAS A PERGUNTA É:


QUAL TASK DEVEMOS RESUMIR ANTES,


A PARENT TASK OU A CHILD TASK?














-->  QUEREMOS, A PARTIR 

DESSA TASK CHILD,



INSERIR NA NOSSA TABLE 


TODOS OS ROWS


QUE TIVERMOS NA TABLE CUSTOMERS (

    a cada minuto, pq esse é o schedule/intervalo 

    da primeira function...
)










AGORA DEVEMOS CRIAR MAIS 1 TASK,






E TAMBÉM CRIAR OUTRA TABLE....








RODAMOS ESTES CÓDIGOS:









-- Prepare a third table 
CREATE OR REPLACE TABLE CUSTOMERS_3 (
    CUSTOMER_ID INT,
    FIRST_NAME VARCHAR(40),
    CREATE_DATE DATE,
    INSERT_DATE DATE DEFAULT DATE(CURRENT_TIMESTAMP)
);


-- Create a child task
CREATE OR REPLACE TASK CUSTOMER_INSERT_TASK_3
    WAREHOUSE = COMPUTE_WH
    AFTER CUSTOMER_INSERT_TASK_2
    AS 
    INSERT INTO CUSTOMERS_3 (
        CUSTOMER_ID,
        FIRST_NAME,
        CREATE_DATE
    ) SELECT * FROM CUSTOMERS_2;






------------------------












OK... CRIAMOS ESSA ÚLTIMA TASK,

QUE VAI COPIAR TUDO DA TABLE CUSTOMERS_2 



PARA A TABLE CUSTOMERS_3,


E APENAS SERÁ 


EXECUTADA 


QUANDO A TASK CUSTOMER_INSERT_TASK_2 


TIVER ACABADO....

















--> COM ISSO, TEMOS ESSAS 3 TASKS...








-> CERTO... 




TAMBÉM PERCEBEMOS QUE SOMOS O OWNER 

DESSAS TASKS,




E TAMBÉM É 

IMPORTANTE 



SABER QUE 





___AS TASKS __ HERDAM OS PRIVILEGES 


DO OWNER QUE AS CRIOU...








--> QUER DIZER QUE 

ESSAS TASKS POSSUEM OS PRIVILEGES 


DO ACCOUNTADMIN...






---------------------------






PODEMOS REPARAR QUE A TASK DE 
"CUSTOMER_INSERT_TASK",


A "ROOT" TASK DE NOSSA TREE,






ELA ESTÁ COM  UM SCHEDULE DE 60 MINUTOS...







TROCAMOS ESSE SCHEDULE PARA 1 MINUTO SÓ,


PARA QUE CONSIGAMOS VERIFICAR OS RESULTS 

MAIS RÁPIDO...



TAMBÉM PRECISAMOS RESUMIR ESSAS TASKS,

PARA AS OBSERVAR EM ACAO...

(SEMPRE COMECE RESUMINDO PELAS 
CHILD TASKS, E NAO PELA ROOT TASK)







POR ISSO RODAMOS ESTES COMANDOS:





-- reduce interval 
ALTER TASK CUSTOMER_INSERT_TASK
SET SCHEDULE = '1 MINUTE';


-- Resume tasks (starting by the CHILD TASKS)
ALTER TASK CUSTOMER_INSERT_TASK_3 RESUME;
ALTER TASK CUSTOMER_INSERT_TASK_2 RESUME;
ALTER TASK CUSTOMER_INSERT_TASK RESUME;



















RODAMOS ISSO... 





O SCHEDULE DA TASK FICOU COMO 1 MINUTE...














--> AGORA TEMOS O ASSUNTO DO RESUME 


DAS TASKS...






--> TODAS AS TASKS ESTAO ATUALMENTE SUSPENDED, É CLARO...










--> SEMPRE comece PELAS 




___CHILD__ TASKS...


















--> OK... COM TODAS NOSSAS TASKS RODANDO,



SABEMOS 


QUE:



1) A PRIMEIRA TASK RODA DE 1 EM 1 MINUTO 



2) A SEGUNDA TASK SÓ RODA SE A PRIMEIRA TASK RODA 


3) A TERCEIRA TASK SÓ RODA SE A SEGUNDA TASK RODA.















certo...








como ficou?










BASTA VERIFICAR COM 1 SELECT:



SELECT * FROM TASK_DB.PUBLIC.CUSTOMERS_3;











esperamos 1 minuto, e entao visualizamos 

o resultado...








-> os conteúdos da table 1 sao 

copiados para a table 2,

e entao sao copiados 

para a table 3,


tudo por conta 


dessa TREE OF TASKS,




POR MEIO DESSE CHAIN DE DEPENDENCIES.










--- se vamos suspender 1 CHAIN DE TASKS, A PRIMEIRA TASK 
-- A SER SUSPENSA DEVERÁ SER A ROOT TASK....
ALTER TASK CUSTOMER_INSERT_TASK SUSPEND;
ALTER TASK CUSTOMER_INSERT_TASK_2 SUSPEND;
ALTER TASK CUSTOMER_INSERT_TASK_3 SUSPEND;














RESUMO DO CÓDIGO DE 

CRIACAO 



DA TREE OF TASKS:







-- root task
CREATE OR REPLACE CUSTOMER_INSERT_TASK
    SCHEDULE='1 minute' -- (ou CRON)
    AS 
    INSERT INTO CUSTOMERS (CREATE_DATE) VALUES (CURRENT_TIMESTAMP);


-- child task 1 
CREATE OR REPLACE CUSTOMER_INSERT_TASK_2 
    AFTER CUSTOMER_INSERT_TASK
    AS
    INSERT INTO CUSTOMERS_2
    SELECT * FROM CUSTOMERS;

-- child task 2 
CREATE OR REPLACE CUSTOMER_INSERT_TASK_3
    AFTER CUSTOMER_INSERT_TASK_2
    AS 
    INSERT INTO _CUSTOMERS_3
    SELECT * FROM CUSTOMERS_2;



-- RESUME the initially suspended tasks (starting by the child tasks):
ALTER TASK CUSTOMER_INSERT_TASK_3 RESUME;
ALTER TASK CUSTOMER_INSERT_TASK_2 RESUME;
ALTER TASK CUSTOMER_INSERT_TASK RESUME;


-- SUSPEND the now started tasks (Starting by the root task):

ALTER TASK CUSTOMER_INSERT_TASK SUSPEND;
ALTER TASK CUSTOMER_INSERT_TASK_2 SUSPEND;
ALTER TASK CUSTOMER_INSERT_TASK_3 SUSPEND;

